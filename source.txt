	// include LED, encoder, and scheduler libraries
#include <LedControl.h>
#include <Encoder.h>
#include <TaskScheduler.h>

	// constant definitions
#define BAUD 57600			// serial comms baud rate (used for debugging)
#define NUMVARS 4			// number of LEDs in display (also how many index locations)
#define NUMDIGS 3			// number of digits in display
#define ARRAY_SIZE 4		// takes the greater of NUMVARS or NUMDIGS to setup the display arrays
#define MAXDIG 9			// largest number for one displayed digit
#define NUMSAMPLES 16		// number of samples used in thermistor averaging
#define TEMP_READ 125		// in ms - delay between thermistor readings
#define OUTPUT_DELAY 50		// in ms - delay between display updates
#define TIMEOUT 10000		// delay (in ms) before display returns to temperature
#define THRESH_PAD 10000	// time (in ms) thermistor must stay on one side of threshold to trigger





	// thermistor calculation definitions
#define RC 3900
#define T0 0.00335401643	// 1 / 298.15
#define B 4500
#define R0 50000

	// define an LED driver chip
LedControl disp = LedControl(LED_DAT, LED_CLK, LED_SEL, 1);

	// define an encoder
Encoder enc = Encoder(ENC1, ENC2);

	// define various task scheduler tasks
Task readTherm(TEMP_READ, -1, &thermRead);
Task circTask(0, -1, &circOn);
Task circOffTask(0, 1, &circOff);
Task updateDisplay(OUTPUT_DELAY, -1, &output);
Scheduler task_scheduler;

	// define working variables
int sum = 0, num = 0;
volatile bool button_pressed = false;





	// button press ISR - sets a variable for mgmt to read (how many button presses this execution)
void buttonHandler() {
	button_pressed = true;
}

	// obtain and average thermistor reading - only outside of IO class for the task scheduler
void thermRead() {
		// receive and adjust thermistor reading to *F
	float F = analogRead(THERM);
	F = (RC * F) / (1023 - F);
	F = log(F / R0);
	F = 1 / (F / B + T0);
	F = F * 1.8 - 459.67;
	sum += round(F);
	num++;
		// if numsamples reached, dump new thermistor reading into the thermistor variable
	if(num == NUMSAMPLES) {
		interface.updateTherm((sum / num));
		sum = num = 0;
	}
}

	// turn the circulator on and enable the circulator off task
void circOn() {
	circulator.turnOn();
	circOffTask.enableDelayed();
}

	// turn the circulator off, reset the circulator off task
void circOff() {
	circulator.turnOff();
	circOffTask.disable();
	circOffTask.setIterations(1);
}

	// tell MetaManagement class to output to IO class (only needed because the task
	// scheduler cannot call the output function directly)
void output() {
	mgmt.output();
}

	// initialize all the things!
void setup() {

		// initialize button ports w/ pullup enabled
	pinMode(BUTTON, INPUT_PULLUP);

		// initialize serial comms for debugging
	//Serial.begin(BAUD);

		// wake up display driver, set brightness, and clear
	disp.shutdown(0, false); disp.setIntensity(0, 8); disp.clearDisplay(0);

		// initialize the encoder
	enc.write(0);
  
		// initialize relay port
	pinMode(RELAY, OUTPUT);

		// initialize button interrupt for indexing
	attachInterrupt(BUTTON - 2, buttonHandler, FALLING);

		// setup periodic tasks
	task_scheduler.init();
	task_scheduler.addTask(readTherm);
	task_scheduler.addTask(updateDisplay);
	task_scheduler.addTask(circTask);
	task_scheduler.addTask(circOffTask);

		// initialize all objects - mostly consists of setting up or retrieving variables
	interface.init();
	circulator.init();
	mgmt.init();

		// start the interface object - the circulator will be started when MetaManagement
		// sees that the threshold has been met
	interface.enable();

}

	// use meta-management class to do stuff and tell task scheduler to continue
	// behind-the-scenes operations (thermistor averaging, outputting, etc.)
void loop() {
	mgmt.execute();
	task_scheduler.execute();
}
